---------------------------------------------------------------------------------------------------------------
---------------------------------------------Friendship层------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
Friendship-1:
如果当前节点所遇到的节点与目的节点是朋友关系时，当前节点就把数据报转发给遇到的节点，否则等待.

---------------------------------------------------------------------------------------------------------------
Friendship-2:
如果当前节点所遇到节点与目的节点的共同朋友的个数比它与目的节点共同朋友的个数多的时候，那么当前节点就把数据报转发给遇到的节点，否则等待.

---------------------------------------------------------------------------------------------------------------
Friendship-3:
分为以下三个步骤：
case1:当前节点所遇到的节点与目的节点是朋友关系且当前节点与目的节点非朋友关系时，当前节点就把数据报转发给遇到的节点;
case2:当前节点所遇到的节点与目的节点非朋友且当前节点与目的节点是朋友关系时，当前节点不转发报文，等待下次相遇在做判断;
case3:(当前节点所遇到的节点与目的节点是朋友关系且当前节点与目的节点也是朋友关系)或者(当前节点所遇到的节点与目的节点非朋友关系且当前节点与目的节点也非朋友关系)，那么使用version 2的策略进行路由.

---------------------------------------------------------------------------------------------------------------
Friendship-SimBet-1:
根据节点之间的朋友关系和节点之间共同朋友的个数建立SocialGraph（两节点相遇1次或1次以上则用边相连），从图中提取similarity和betweenness等社交属性，根据这些社交属性进行路由时的中继选择。

---------------------------------------------------------------------------------------------------------------
Friendship-SimBet-2:
根据节点之间的朋友关系和节点之间共同朋友的个数建立SocialGraph（两节点相遇2次或2次以上则用边相连），从图中提取similarity和betweenness等社交属性，根据这些社交属性进行路由时的中继选择。

---------------------------------------------------------------------------------------------------------------
---------------------------------------------Proximity层-------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
Proximity-SimBet-1：
首先利用选取一个时间段，统计出该时间段内节点之间相互探测到对方（碰撞）的碰撞矩阵contactMatrix，然后根据此建立SocialGraph（两节点相遇1次或1次以上则用边相连），从图中提取similarity和betweenness等社交属性，根据这些社交属性进行路由时的中继选择。

---------------------------------------------------------------------------------------------------------------
Proximity-SimBet-2：
首先利用选取一个时间段，统计出该时间段内节点之间相互探测到对方（碰撞）的碰撞矩阵contactMatrix，然后根据此建立SocialGraph（两节点相遇2次或2次以上则用边相连），从图中提取similarity和betweenness等社交属性，根据这些社交属性进行路由时的中继选择。

---------------------------------------------------------------------------------------------------------------
Proximity-SimBet-3：
首先利用选取一个时间段，统计出该时间段内节点之间相互探测到对方（碰撞）的碰撞矩阵contactMatrix，然后根据此建立SocialGraph（两节点相遇3次或3次以上则用边相连），从图中提取similarity和betweenness等社交属性，根据这些社交属性进行路由时的中继选择。

---------------------------------------------------------------------------------------------------------------
Proximity-SimBet-4：
首先利用选取一个时间段，统计出该时间段内节点之间相互探测到对方（碰撞）的碰撞矩阵contactMatrix，然后根据此建立SocialGraph（两节点相遇4次或4次以上则用边相连），从图中提取similarity和betweenness等社交属性，根据这些社交属性进行路由时的中继选择。

---------------------------------------------------------------------------------------------------------------
Epidemic：
洪泛式转发。

---------------------------------------------------------------------------------------------------------------
Greedy-Total：
如果当前节点与网络中其他节点相遇的次数没有其遇到的节点与其他节点相遇的次数多，当前节点就把数据报转发给遇到的节点，否则等待.

---------------------------------------------------------------------------------------------------------------
---------------------------------------------Transmission层----------------------------------------------------
---------------------------------------------------------------------------------------------------------------
TransmissionRouting:
首先根据transmission.arff中的数据将节点间相互发送消息的次数保存在transmissionCountMatrix矩阵中。
如果当前节点与目的节点的通信次数（发送报文的次数）小于其遇到的节点与目的节点的通信次数，那么就把自己携带的报文转发给遇到的节点，否则等待。

---------------------------------------------------------------------------------------------------------------
Transmission-SimBet-1:
首先利用选取一个时间段，统计出该时间段内节点之间相互发送消息的次数矩阵transmissionMatrix，然后根据此建立SocialGraph（两节点相遇1次或1次以上则用边相连），从图中提取similarity和betweenness等社交属性，根据这些社交属性进行路由时的中继选择。

---------------------------------------------------------------------------------------------------------------
Transmission-SimBet-2:
首先利用选取一个时间段，统计出该时间段内节点之间相互发送消息的次数矩阵transmissionMatrix，然后根据此建立SocialGraph（两节点相遇2次或2次以上则用边相连），从图中提取similarity和betweenness等社交属性，根据这些社交属性进行路由时的中继选择。

---------------------------------------------------------------------------------------------------------------
Transmission-SimBet-3:
首先利用选取一个时间段，统计出该时间段内节点之间相互发送消息的次数矩阵transmissionMatrix，然后根据此建立SocialGraph（两节点相遇3次或3次以上则用边相连），从图中提取similarity和betweenness等社交属性，根据这些社交属性进行路由时的中继选择。

---------------------------------------------------------------------------------------------------------------
Transmission-SimBet-4:
首先利用选取一个时间段，统计出该时间段内节点之间相互发送消息的次数矩阵transmissionMatrix，然后根据此建立SocialGraph（两节点相遇4次或4次以上则用边相连），从图中提取similarity和betweenness等社交属性，根据这些社交属性进行路由时的中继选择。

---------------------------------------------------------------------------------------------------------------
---------------------------------------------Interest层--------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
InterestRouting:
首先根据interests.arff中的数据将统计每两个节点之间共同兴趣的个数，并保存在矩阵中。
如果当前节点与目的节点的共同兴趣个数小于其遇到的节点与目的节点的共同兴趣个数，那么就把自己携带的报文转发给遇到的节点，否则等待。

---------------------------------------------------------------------------------------------------------------
Interest-SimBet-1:
统计出网络中每两个节点之间共有的兴趣个数矩阵commonInterestMatrix，然后根据此建立SocialGraph（两节点相遇1次或1次以上则用边相连），从图中提取similarity和betweenness等社交属性，根据这些社交属性进行路由时的中继选择。

---------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------
Interest-SimBet-2:
统计出网络中每两个节点之间共有的兴趣个数矩阵commonInterestMatrix，然后根据此建立SocialGraph（两节点相遇2次或2次以上则用边相连），从图中提取similarity和betweenness等社交属性，根据这些社交属性进行路由时的中继选择。

---------------------------------------------------------------------------------------------------------------
OrRouting：
满足一层或一层以上的要求则转发。
GreaterThan2Routing：
满足两层或两层以上的要求则转发。
GreaterThan2Routing：
满足三层或三层以上的要求则转发。
AndRouting：
四层条件都满足才转发。
具体解释每层判断标准，假设i节点想发一个到d的报文，某时刻遇到了j节点：
Friendship层判断是否满足：commonFriends[j][d] >= commonFriends[i][d]
Interest层判断是否满足：commonInterest[j][d] >= commonInterest[i][d]
Proximity层判断是否满足：betweenness[j] >= betweenness[i]
Transmission层判断是否满足：transmissionCountMatrix[j][d] >= transmissionCountMatrix[i][d]

---------------------------------------------------------------------------------------------------------------
FIPTRouting(Friend-Interest-Proximity-Transmission Routing)：
假设i节点想发一个到d的报文，某时刻遇到了j节点：
friendsUtil_i = commonFriends[i][d]/(commonFriends[i][d]+commonFriends[j][d])
interestUtil_i = commonInterest[i][d]/(commonInterest[i][d]+commonInterest[j][d])
proximityUtil_i = contactCountMatrix[i][d]/(contactCountMatrix[i][d]+contactCountMatrix[j][d])
transmissionUtil_i = transmissionCountMatrix[i][d]/(transmissionCountMatrix[i][d]+transmissionCountMatrix[j][d])
fipt_i = friendsUtil_i + interestUtil_i + proximityUtil_i + transmissionUtil_i
同理计算fipt_j
此时，如果节点j的fipt值大于节点i的fipt值，那么节点i将报文转发给节点j，否则节点i继续携带报文。

---------------------------------------------------------------------------------------------------------------
FIPT-I：
假设i节点想发一个到d的报文，某时刻遇到了j节点：
friendsUtil_i = commonFriends[i][d]/(commonFriends[i][d]+commonFriends[j][d])
interestUtil_i = commonInterest[i][d]/(commonInterest[i][d]+commonInterest[j][d])
proximityUtil_i = contactCountMatrix[i][d]/(contactCountMatrix[i][d]+contactCountMatrix[j][d])
transmissionUtil_i = transmissionCountMatrix[i][d]/(transmissionCountMatrix[i][d]+transmissionCountMatrix[j][d])
fipt_i = 权值1*friendsUtil_i + 权值2*interestUtil_i + 权值3*proximityUtil_i + 权值4*transmissionUtil_i
同理计算fipt_j （这里权值为利用该单层数据计算得到的平均delivery ratio）
此时，如果节点j的fipt值大于节点i的fipt值，那么节点i将报文转发给节点j，否则节点i继续携带报文。


