Friendship-1:
如果当前节点所遇到的节点与目的节点是朋友关系时，当前节点就把数据报转发给遇到的节点，否则等待.

---------------------------------------------------------------------------------------------------------------
Friendship-2:
如果当前节点所遇到节点与目的节点的共同朋友的个数比它与目的节点共同朋友的个数多的时候，那么当前节点就把数据报转发给遇到的节点，否则等待.

---------------------------------------------------------------------------------------------------------------
Friendship-3:
分为以下三个步骤：
case1:当前节点所遇到的节点与目的节点是朋友关系且当前节点与目的节点非朋友关系时，当前节点就把数据报转发给遇到的节点;
case2:当前节点所遇到的节点与目的节点非朋友且当前节点与目的节点是朋友关系时，当前节点不转发报文，等待下次相遇在做判断;
case3:(当前节点所遇到的节点与目的节点是朋友关系且当前节点与目的节点也是朋友关系)或者(当前节点所遇到的节点与目的节点非朋友关系且当前节点与目的节点也非朋友关系)，那么使用version 2的策略进行路由.

---------------------------------------------------------------------------------------------------------------
Friendship-SimBet:
根据节点之间的朋友关系和节点之间共同朋友的个数建立SocialGraph，从图中提取similarity和betweenness等社交属性，根据这些社交属性进行路由时的中继选择。

---------------------------------------------------------------------------------------------------------------
Proximity-SimBet：
首先利用选取一个时间段，统计出该时间段内节点之间相互探测到对方（碰撞）的碰撞矩阵contactMatrix，然后根据此建立SocialGraph，从图中提取similarity和betweenness等社交属性，根据这些社交属性进行路由时的中继选择。

---------------------------------------------------------------------------------------------------------------
Epidemic：
大家都很熟悉了就不解释了。

---------------------------------------------------------------------------------------------------------------
TransmissionRouting:
首先根据transmission.arff中的数据将节点间相互发送消息的次数保存在transmissionCountMatrix矩阵中。
如果当前节点与目的节点的通信次数（发送报文的次数）小于其遇到的节点与目的节点的通信次数，那么就把自己携带的报文转发给遇到的节点，否则等待。

---------------------------------------------------------------------------------------------------------------
InterestRouting:
首先根据interests.arff中的数据将统计每两个节点之间共同兴趣的个数，并保存在矩阵中。
如果当前节点与目的节点的共同兴趣个数小于其遇到的节点与目的节点的共同兴趣个数，那么就把自己携带的报文转发给遇到的节点，否则等待。